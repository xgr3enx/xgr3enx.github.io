<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Playable Skyway 5</title>
  <style>
    :root {
      --bg: #b8e4f5;
      --panel: #f4f4f4;
      --lane: #f3f3f3;
      --magenta: #d54de9;
      --red: #ef4141;
      --green: #62c90f;
      --blue: #4b7fe0;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: none;
      background: var(--bg);
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
    }

    #app {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: linear-gradient(180deg, #bde8f8 0%, #b6e2f4 100%);
    }

    #scene {
      position: absolute;
      left: 50%;
      top: 20px;
      width: calc(100vw - 40px);
      height: calc(100vh - 40px);
      transform: translateX(-50%);
      overflow: hidden;
    }

    @media (orientation: landscape) {
      #scene {
        width: min(calc(100vw - 40px), calc((100vh - 40px) * 0.68));
      }
    }

    .level {
      position: absolute;
      left: 20px;
      top: 20px;
      width: auto;
      height: auto;
      padding: 10px 18px;
      border-radius: 2.8vmin;
      background: #f0efed;
      box-shadow: inset 0 .75vmin 0 rgba(255,255,255,.55);
      color: #4f579d;
      font-size: clamp(26px, 4.8vmin, 40px);
      font-weight: 900;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      line-height: 1;
      letter-spacing: .4px;
      z-index: 20;
    }

    .lane-wrap {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: -0.5%;
      width: 37.8%;
      height: 48.3%;
      pointer-events: none;
      z-index: 8;
    }

    .lane {
      position: absolute;
      width: 29.4%;
      height: 84%;
      bottom: 6%;
      border-radius: 1.2vmin;
      background: var(--lane);
      box-shadow: inset 0 .55vmin 1vmin rgba(0,0,0,.08);
    }
    .lane.left { left: 0; }
    .lane.right { right: 0; }

    .lane::after {
      content: "";
      position: absolute;
      left: 50%;
      bottom: -1.35%;
      width: 74%;
      height: 3.2%;
      transform: translateX(-50%);
      border-radius: 1vmin;
      background: #5f5f5f;
      box-shadow: -2.8vmin .7vmin 0 -.35vmin #6a6a6a, 2.8vmin .7vmin 0 -.35vmin #6a6a6a;
    }

    #figureLayer {
      position: absolute;
      inset: 0;
    }

    .figure {
      position: absolute;
      border-radius: 1.85vmin;
      border: .34vmin solid rgba(0,0,0,.16);
      box-shadow: inset 0 .65vmin 0 rgba(255,255,255,.29);
      padding: .58vmin;
      transform-origin: center;
      opacity: 1;
      transition: opacity .25s ease;
    }
    .figure.gone {
      animation: figGone .34s ease forwards;
    }
    @keyframes figGone {
      to { transform: scale(.3); opacity: 0; }
    }

    .figure-grid {
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: .46vmin;
    }

    .figure-slot {
      border-radius: .73vmin;
      background: rgba(255,255,255,.12);
      border: .18vmin solid rgba(255,255,255,.19);
      transform: scale(1);
    }
    .figure-slot.filled {
      animation: pop .14s ease;
    }

    .board {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: 48.1%;
      width: 50.8%;
      aspect-ratio: 1;
      border-radius: 2.5vmin;
      background: var(--panel);
      box-shadow: 0 .7vmin 1.2vmin rgba(0,0,0,.08);
      padding: 2.05%;
      z-index: 12;
      touch-action: none;
    }

    #grid {
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-template-rows: repeat(6, 1fr);
      gap: 3.15%;
      position: relative;
      z-index: 2;
    }

    .cell {
      border-radius: 1.05vmin;
      box-shadow: inset 0 .35vmin .42vmin rgba(255,255,255,.35), 0 .16vmin .42vmin rgba(0,0,0,.08);
      transform: scale(1);
      transition: transform .09s ease, filter .09s ease, opacity .12s ease;
    }
    .cell.selected {
      transform: scale(.9);
      filter: brightness(1.12);
    }
    .cell.outgoing {
      opacity: .34;
    }

    #linkLayer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 5;
      pointer-events: none;
      overflow: visible;
    }

    .side-indicator {
      position: absolute;
      bottom: 1.8%;
      width: .95%;
      height: 33%;
      border-radius: 1vmin;
      opacity: 0;
      transition: opacity .12s ease;
      z-index: 14;
      pointer-events: none;
    }
    .side-indicator.left { left: 2.2%; }
    .side-indicator.right { right: 2.2%; }

    .fly {
      position: fixed;
      left: 0;
      top: 0;
      border-radius: 1.05vmin;
      box-shadow: inset 0 .35vmin .42vmin rgba(255,255,255,.35), 0 .16vmin .42vmin rgba(0,0,0,.08);
      pointer-events: none;
      z-index: 30;
      will-change: transform;
    }

    #endcard {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      color: #fff;
      z-index: 40;
      background: linear-gradient(180deg, rgba(84,168,222,.95), rgba(34,119,178,.97));
      padding: 6vmin;
    }
    #endcard.show { display: flex; }
    #endcard h1 {
      margin: 0;
      font-size: clamp(38px, 10vmin, 80px);
      line-height: 1;
      text-transform: uppercase;
      text-shadow: 0 .45vmin .85vmin rgba(0,0,0,.25);
    }
    #endcard p {
      margin: 2.3vmin 0 4.4vmin;
      font-size: clamp(20px, 4.4vmin, 36px);
      font-weight: 700;
    }
    #cta {
      border: none;
      border-radius: 999px;
      padding: 2vmin 7vmin;
      background: #fff16b;
      color: #244994;
      font-size: clamp(22px, 4.6vmin, 38px);
      font-weight: 900;
      box-shadow: 0 .72vmin 0 #d8bf25;
    }

    @keyframes pop {
      0% { transform: scale(.45); opacity: .65; }
      100% { transform: scale(1); opacity: 1; }
    }

  </style>
</head>
<body>
  <div id="app">
    <div class="level">Level 23</div>
    <div id="scene">
      <div class="lane-wrap" id="laneWrap">
        <div class="lane left"></div>
        <div class="lane right"></div>
        <div id="figureLayer"></div>
      </div>

      <div class="board" id="board">
        <div id="grid"></div>
        <svg id="linkLayer" viewBox="0 0 100 100" preserveAspectRatio="none">
          <polyline id="poly" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="3.1" points="" />
          <circle id="dot" r="0" cx="0" cy="0" fill="none" />
        </svg>
      </div>

      <div class="side-indicator left" id="sideLeft"></div>
      <div class="side-indicator right" id="sideRight"></div>
    </div>

    <div id="endcard">
      <h1>Great!</h1>
      <p>Level Complete</p>
      <button id="cta">Install</button>
    </div>
  </div>

  <script>
    (() => {
      const css = getComputedStyle(document.documentElement);
      const palette = {
        magenta: css.getPropertyValue("--magenta").trim(),
        red: css.getPropertyValue("--red").trim(),
        green: css.getPropertyValue("--green").trim(),
        blue: css.getPropertyValue("--blue").trim()
      };
      const keys = Object.keys(palette);

      const GRID = 6;
      const SPEED_PX_PER_SEC = 16;
      const gridState = [];

      const figureQueue = [
        { id: "magenta_4", color: "magenta", lane: "left", rows: 2, cols: 2 },
        { id: "green_4", color: "green", lane: "right", rows: 2, cols: 2 },
        { id: "red_4", color: "red", lane: "left", rows: 2, cols: 2 },
        { id: "blue_4", color: "blue", lane: "right", rows: 2, cols: 2 },
        { id: "magenta_6", color: "magenta", lane: "left", rows: 3, cols: 2 },
        { id: "red_6", color: "red", lane: "right", rows: 3, cols: 2 },
        { id: "green_6", color: "green", lane: "left", rows: 3, cols: 2 },
        { id: "blue_6", color: "blue", lane: "right", rows: 3, cols: 2 },
        { id: "magenta_8", color: "magenta", lane: "left", rows: 4, cols: 2 },
        { id: "green_8", color: "green", lane: "right", rows: 4, cols: 2 }
      ];

      const scene = document.getElementById("scene");
      const board = document.getElementById("board");
      const grid = document.getElementById("grid");
      const laneWrap = document.getElementById("laneWrap");
      const figureLayer = document.getElementById("figureLayer");
      const poly = document.getElementById("poly");
      const dot = document.getElementById("dot");
      const sideLeft = document.getElementById("sideLeft");
      const sideRight = document.getElementById("sideRight");
      const endcard = document.getElementById("endcard");

      let figures = [];
      let dragging = false;
      let dragColor = null;
      let dragPath = [];
      let pointer = null;
      let locked = false;
      let gameOver = false;
      let lastTick = 0;

      function randKey() {
        return keys[(Math.random() * keys.length) | 0];
      }

      function buildFigureDefs() {
        const laneTier = { left: 0, right: 0 };
        return figureQueue.map((def) => {
          const tier = laneTier[def.lane] || 0;
          laneTier[def.lane] = tier + 1;
          return { ...def, tier };
        });
      }

      function buildGrid() {
        grid.innerHTML = "";
        for (let r = 0; r < GRID; r++) {
          const row = [];
          for (let c = 0; c < GRID; c++) {
            const key = randKey();
            row.push(key);
            const cell = document.createElement("div");
            cell.className = "cell";
            cell.dataset.r = String(r);
            cell.dataset.c = String(c);
            cell.style.background = palette[key];
            grid.appendChild(cell);
          }
          gridState.push(row);
        }
      }

      function createFigure(def) {
        const el = document.createElement("div");
        el.className = "figure";
        el.style.background = palette[def.color];

        const inner = document.createElement("div");
        inner.className = "figure-grid";
        inner.style.gridTemplateColumns = `repeat(${def.cols}, 1fr)`;
        inner.style.gridTemplateRows = `repeat(${def.rows}, 1fr)`;
        el.appendChild(inner);

        const slots = [];
        const total = def.rows * def.cols;
        for (let i = 0; i < total; i++) {
          const s = document.createElement("div");
          s.className = "figure-slot";
          s.dataset.i = String(i);
          inner.appendChild(s);
          slots.push(s);
        }

        figureLayer.appendChild(el);
        return {
          ...def,
          el,
          slots,
          slotFilled: new Array(total).fill(false),
          filled: 0,
          removed: false,
          gone: false,
          x: 0,
          y: 0,
          w: 0,
          h: 0,
          startY: 0,
          failY: 0
        };
      }

      function layoutFigures(preserveProgress) {
        const wrapW = laneWrap.clientWidth;
        const wrapH = laneWrap.clientHeight;
        const wrapRect = laneWrap.getBoundingClientRect();
        const laneW = wrapW * 0.294;
        const leftLaneX = 0;
        const rightLaneX = wrapW - laneW;
        const stackGap = wrapH * 0.016;

        // Pass 1: size and X-position for each figure.
        for (const fig of figures) {
          const rangePrev = Math.max(1, fig.failY - fig.startY);
          const progress = preserveProgress ? Math.max(0, Math.min(1, (fig.y - fig.startY) / rangePrev)) : 0;

          fig.w = laneW * 0.86;
          fig.h = fig.w * (fig.rows / fig.cols) + wrapW * 0.015;

          const laneX = fig.lane === "left" ? leftLaneX : rightLaneX;
          fig.x = laneX + (laneW - fig.w) / 2;

          fig.el.style.width = `${fig.w}px`;
          fig.el.style.height = `${fig.h}px`;
          fig.__progress = progress;
        }

        // Pass 2: stack by lane using cumulative heights + constant gap.
        const laneOffsets = { left: 0, right: 0 };
        const ordered = [...figures].sort((a, b) => {
          if (a.lane === b.lane) return a.tier - b.tier;
          return a.lane < b.lane ? -1 : 1;
        });

        for (const fig of ordered) {
          const stackOffset = laneOffsets[fig.lane];
          laneOffsets[fig.lane] += fig.h + stackGap;

          // Spawn above the visible viewport, then move down into lanes.
          fig.startY = -wrapRect.top - fig.h - 24 - stackOffset;
          // Gray strip is near the lane bottom; reaching this top position ends the game.
          fig.failY = wrapH * 0.915 - fig.h;
          fig.y = fig.startY + (fig.failY - fig.startY) * fig.__progress;
          placeFigure(fig);
        }
      }

      function placeFigure(fig) {
        fig.el.style.left = `${fig.x}px`;
        fig.el.style.top = `${fig.y}px`;
      }

      function animateFigures(ts) {
        if (!lastTick) lastTick = ts;
        const dt = (ts - lastTick) / 1000;
        lastTick = ts;

        if (!locked && !gameOver) {
          for (const fig of figures) {
            if (fig.removed) continue;
            fig.y += SPEED_PX_PER_SEC * dt;
            if (fig.y >= fig.failY) {
              fig.y = fig.failY;
              placeFigure(fig);
              triggerEndcard();
              break;
            }
            placeFigure(fig);
          }
        }

        requestAnimationFrame(animateFigures);
      }

      function triggerEndcard() {
        if (gameOver) return;
        gameOver = true;
        endcard.classList.add("show");
      }

      function cellFromPoint(x, y) {
        const el = document.elementFromPoint(x, y);
        if (!el || !el.classList.contains("cell")) return null;
        return el;
      }

      function isAdjacent(a, b) {
        const dr = Math.abs(a.r - b.r);
        const dc = Math.abs(a.c - b.c);
        return dr <= 1 && dc <= 1 && (dr + dc > 0);
      }

      function clearPath() {
        for (const n of dragPath) {
          n.el.classList.remove("selected");
        }
        dragPath = [];
        pointer = null;
        poly.setAttribute("points", "");
        dot.setAttribute("r", "0");
      }

      function setIndicators(key, show) {
        const color = key ? palette[key] : "transparent";
        sideLeft.style.background = color;
        sideRight.style.background = color;
        const opacity = show ? "1" : "0";
        sideLeft.style.opacity = opacity;
        sideRight.style.opacity = opacity;
      }

      function boardPoint(cell) {
        const br = board.getBoundingClientRect();
        const cr = cell.getBoundingClientRect();
        return {
          x: ((cr.left + cr.width / 2) - br.left) / br.width * 100,
          y: ((cr.top + cr.height / 2) - br.top) / br.height * 100
        };
      }

      function drawPath() {
        if (!dragPath.length) {
          poly.setAttribute("points", "");
          dot.setAttribute("r", "0");
          return;
        }

        const pts = dragPath.map((p) => {
          const b = boardPoint(p.el);
          return `${b.x.toFixed(3)},${b.y.toFixed(3)}`;
        });

        if (pointer) {
          const br = board.getBoundingClientRect();
          const x = ((pointer.x - br.left) / br.width) * 100;
          const y = ((pointer.y - br.top) / br.height) * 100;
          pts.push(`${x.toFixed(3)},${y.toFixed(3)}`);
          dot.setAttribute("cx", x.toFixed(3));
          dot.setAttribute("cy", y.toFixed(3));
          dot.setAttribute("r", "1.55");
          dot.setAttribute("fill", palette[dragColor]);
        } else {
          dot.setAttribute("r", "0");
        }

        poly.setAttribute("stroke", palette[dragColor]);
        poly.setAttribute("points", pts.join(" "));
      }

      function tryExtendPath(cell) {
        const r = Number(cell.dataset.r);
        const c = Number(cell.dataset.c);
        const key = gridState[r][c];
        if (key !== dragColor) return;

        const exists = dragPath.findIndex((p) => p.r === r && p.c === c);
        if (exists >= 0) {
          if (dragPath.length > 1 && exists === dragPath.length - 2) {
            const removed = dragPath.pop();
            removed.el.classList.remove("selected");
          }
          drawPath();
          return;
        }

        const prev = dragPath[dragPath.length - 1];
        if (!prev || !isAdjacent(prev, { r, c })) return;
        dragPath.push({ r, c, el: cell });
        cell.classList.add("selected");
        drawPath();
      }

      function findTargetFigure(key) {
        let target = null;
        for (const fig of figures) {
          if (fig.removed || fig.gone) continue;
          if (fig.color !== key) continue;
          if (fig.filled >= fig.slotFilled.length) continue;
          if (!target || fig.y > target.y) {
            target = fig;
          }
        }
        return target;
      }

      function emptySlots(fig, limit) {
        const out = [];
        for (let i = 0; i < fig.slotFilled.length; i++) {
          if (!fig.slotFilled[i]) out.push(i);
          if (out.length >= limit) break;
        }
        return out;
      }

      function setCellColor(cell, r, c, key) {
        gridState[r][c] = key;
        cell.style.background = palette[key];
      }

      function animateTransfer(node, fig, slotIndex, idx) {
        return new Promise((resolve) => {
          const src = node.el.getBoundingClientRect();
          const size = src.width;
          const fly = document.createElement("div");
          fly.className = "fly";
          fly.style.width = `${size}px`;
          fly.style.height = `${size}px`;
          fly.style.background = palette[fig.color];
          fly.style.transform = `translate3d(${src.left}px, ${src.top}px, 0) scale(1)`;
          document.body.appendChild(fly);

          node.el.classList.add("outgoing");
          node.el.classList.remove("selected");

          const startX = src.left;
          const startY = src.top;
          const start = performance.now() + idx * 35;
          const dur = 340;

          function frame(now) {
            if (now < start) {
              requestAnimationFrame(frame);
              return;
            }

            const t = Math.min(1, (now - start) / dur);
            const e = 1 - Math.pow(1 - t, 3);

            const slot = fig.slots[slotIndex];
            const tr = slot.getBoundingClientRect();
            const targetX = tr.left + tr.width / 2 - size / 2;
            const targetY = tr.top + tr.height / 2 - size / 2;

            const x = startX + (targetX - startX) * e;
            const y = startY + (targetY - startY) * e;
            const s = 1 - 0.22 * e;
            fly.style.transform = `translate3d(${x}px, ${y}px, 0) scale(${s})`;

            if (t < 1) {
              requestAnimationFrame(frame);
              return;
            }

            fly.remove();
            fig.slotFilled[slotIndex] = true;
            fig.filled += 1;
            slot.style.background = palette[fig.color];
            slot.classList.add("filled");

            const newKey = randKey();
            setCellColor(node.el, node.r, node.c, newKey);
            node.el.classList.remove("outgoing");

            resolve();
          }

          requestAnimationFrame(frame);
        });
      }

      function removeFigure(fig) {
        if (gameOver) return;
        fig.gone = true;
        fig.el.classList.add("gone");
        setTimeout(() => {
          fig.removed = true;
          fig.el.style.display = "none";
          if (figures.every((f) => f.removed)) {
            triggerEndcard();
          }
        }, 340);
      }

      async function commitDrag() {
        const valid = dragPath.length >= 2 && !locked && !gameOver;
        if (!valid) {
          clearPath();
          return;
        }

        const target = findTargetFigure(dragColor);
        if (!target) {
          clearPath();
          return;
        }

        const free = target.slotFilled.length - target.filled;
        const count = Math.min(free, dragPath.length);
        if (count <= 0) {
          clearPath();
          return;
        }

        const movingNodes = dragPath.slice(0, count);
        const slots = emptySlots(target, count);
        locked = true;
        clearPath();

        await Promise.all(movingNodes.map((n, i) => animateTransfer(n, target, slots[i], i)));

        if (target.filled >= target.slotFilled.length && !target.gone) {
          removeFigure(target);
        }

        locked = false;
      }

      function onPointerDown(e) {
        if (locked || gameOver || endcard.classList.contains("show")) return;
        const cell = cellFromPoint(e.clientX, e.clientY);
        if (!cell) return;

        dragging = true;
        pointer = { x: e.clientX, y: e.clientY };

        const r = Number(cell.dataset.r);
        const c = Number(cell.dataset.c);
        dragColor = gridState[r][c];
        setIndicators(dragColor, true);

        dragPath = [{ r, c, el: cell }];
        cell.classList.add("selected");
        drawPath();
      }

      function onPointerMove(e) {
        if (!dragging) return;
        pointer = { x: e.clientX, y: e.clientY };
        const cell = cellFromPoint(e.clientX, e.clientY);
        if (cell) {
          tryExtendPath(cell);
        } else {
          drawPath();
        }
      }

      function onPointerUp() {
        if (!dragging) return;
        dragging = false;
        pointer = null;
        setIndicators(null, false);
        commitDrag();
      }

      function onResize() {
        layoutFigures(true);
      }

      function init() {
        buildGrid();
        figureLayer.innerHTML = "";
        figures = buildFigureDefs().map(createFigure);
        layoutFigures(false);
        requestAnimationFrame(animateFigures);

        board.addEventListener("pointerdown", onPointerDown);
        window.addEventListener("pointermove", onPointerMove, { passive: true });
        window.addEventListener("pointerup", onPointerUp, { passive: true });
        window.addEventListener("pointercancel", onPointerUp, { passive: true });
        window.addEventListener("resize", onResize);

        document.getElementById("cta").addEventListener("click", () => {
          window.open("https://example.com", "_blank");
        });
      }

      init();
    })();
  </script>
</body>
</html>
